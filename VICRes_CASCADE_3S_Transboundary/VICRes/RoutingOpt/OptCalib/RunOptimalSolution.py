# coding: utf-8
# Code: Environmental Intelligence Lab / Polimi
# author: bruno
# ------------------------------------------------------------------------------------------------------------------------------------------------
'''
This code is a modified version of the original optimization.py found in VICRes_CASCADE_3S_Opt. Its purpose is to run all Pareto-efficient solutions obtained
from the optimization step and save the complete results. These results include not only the objective values considered during optimization but also all outputs
typically generated by VICRes.
Each simulation will save its results in the directory RoutingSetupCores/RoutingSetup3S33{n}/Results, where {n} represents the ID of the Pareto-optimal solution 
being processed (001, 002, 003, ... up to N, where N is the total number of Pareto-optimal solutions found).
If you run it using multiple cores, make sure that you have prepared the right number of folders for running the coupled framework in parallel 
(one folder for each core, to create different socket connections and save the different results).
If you need further information to run the script for optiomization contact: bruno.invernizzi@polimi.it
'''
# ------------------------------------------------------------------------------------------------------------------------------------------------

from platypus import EpsNSGAII, Problem, Real, Integer, ProcessPoolEvaluator, Hypervolume, nondominated
import os
import csv
import time
import numpy as np
import multiprocessing
import datetime
import math
import subprocess
from datetime import timedelta
from concurrent.futures import ProcessPoolExecutor


# ------------------------------------------------------------------------------------------------------------------------------------------------

def parallel_execution(varnew_unique, number_of_cores):
    inputs = [(varnew_unique[i, :], i) for i in range(1,10)]  #(200,len(varnew_unique))]
    results = []

    with ProcessPoolExecutor(max_workers=number_of_cores) as executor:
        # Map assegna in parallelo la funzione viccal ai dati
        results = list(executor.map(viccall, inputs))

    return results


def viccall(inputs):
    # Declare decision variables (VIC)
    varnew, curr_sol = inputs
    # Simulazione di elaborazione
    print(f"Processing i={curr_sol}")
    global maximum_no_reservoirs
    global number_of_days
    global spinning_period
    global reservoirs
    totalinstallcapcity = 0
    os.chdir('../../RoutingSetup3S_Opt')
    number_of_days = 5479
    spinning_period = 0
    maximum_no_reservoirs = 9
    number_of_cores = 20
    reservoirs = [[0 for x in range(3)] for y in range(maximum_no_reservoirs)]  
    
    reservoirs[0][0] = 7
    reservoirs[1][0] = 11
    reservoirs[2][0] = 8
    reservoirs[3][0] = 109
    reservoirs[4][0] = 2
    reservoirs[5][0] = 3
    reservoirs[6][0] = 6
    reservoirs[7][0] = 22
    reservoirs[8][0] = 13

    os.chdir('../RoutingSetup3S_Opt/Results')
    # Starting the process
    port=33000
    rank = curr_sol+1
    #print("-----------------------------------------------------------------------------------")
    #print("Thread no: ",rank," out of ",multiprocessing.cpu_count())
    #maximum_no_reservoirs=1
    # Modify reservoir parameters
    port=port+rank
    countrow = 0
    directory = f"../../ReservoirsCores/ReservoirsOpt{port}"
    os.chdir(directory)
    D5demand = [0.0 for x in range(12)]
    #time.sleep(rank*2)
    vars = varnew
    for i in range(maximum_no_reservoirs):
        text_file = open('res'+str(reservoirs[i][0])+'.txt','r')
        lines = text_file.read().split('\n')
        hmax = float(lines[1].split('\t')[0])
        hmin = float(lines[1].split('\t')[1])
        volume = float(lines[1].split('\t')[2])
        dvolume = float(lines[1].split('\t')[3])
        height = float(lines[1].split('\t')[4])
        discharge = float(lines[1].split('\t')[5])
        yearopt = int(lines[1].split('\t')[6])
        initialvolume = float(lines[1].split('\t')[7])
        resname = lines[1].split('\t')[8]
        seepage = float(lines[3].split('\t')[0])
        infil = float(lines[3].split('\t')[1])
        opt = int(lines[8].split('\t')[0])
        if (opt==3):
            D4demand = float(lines[6].split('\t')[0])
        elif (opt==5):
            for j in range(12):
                D5demand[j] = float(lines[6+j].split('\t')[0])
        sedopt = int(lines[11].split('\t')[0])
        if (sedopt==1):
            maxrate=float(lines[13].split('\t')[2])
            maxwl=float(lines[13].split('\t')[5])
            mindisch=float(lines[13].split('\t')[6])
            width=float(lines[13].split('\t')[7])
            slope=float(lines[13].split('\t')[8])
            length=float(lines[13].split('\t')[9])
            gatelevel=float(lines[13].split('\t')[10])
            bottomcap=float(lines[13].split('\t')[11])
        elif (sedopt==2):
            maxrate=float(lines[13].split('\t')[2])
            maxwl=float(lines[13].split('\t')[5])
            mindisch=float(lines[13].split('\t')[6])
            width=float(lines[13].split('\t')[7])
            slope=float(lines[13].split('\t')[8])
            length=float(lines[13].split('\t')[9])
            gatelevel=float(lines[13].split('\t')[10])
            bottomcap=float(lines[13].split('\t')[11])
        text_file.close()
        with open('res'+str(reservoirs[i][0])+'.txt','w') as my_csv:
            my_csv.write("Hmax(M)	Hmin(M)	Scap(1000M3)	Sd(1000M3)	Hturbine(M)	Qdesign (M3/s)	Year	Sinitial(1000M3)	Name\n")
            my_csv.write("%f\t%f\t%f\t%f\t%f\t%f\t%i\t%f\t%s\n"%(hmax,hmin,volume,dvolume,height,discharge,yearopt,initialvolume,resname))
            my_csv.write("SEEPAGE	INFILTRATION\n")
            my_csv.write("%f\t%f\n"%(seepage,infil))
            my_csv.write("IRRIGATION\n")
            my_csv.write("%d\n"%0)
            my_csv.write("DUMMY\n")
            my_csv.write("OPERATION STRATEGY\n")
            my_csv.write(str(opt)+"\n")
            if (opt==1):
                my_csv.write("%f\t%f\t%i\t%i\n"%(vars[countrow],vars[countrow+1],vars[countrow+2],vars[countrow+3]))
                countrow+=4
            elif (opt==2):
                my_csv.write("%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\t%f\n"%(vars[countrow],vars[countrow+1],vars[countrow+2],vars[countrow+3],vars[countrow+4],
                vars[countrow+5],vars[countrow+6],vars[countrow+7],vars[countrow+8],vars[countrow+9],vars[countrow+10],vars[countrow+11]))
                countrow+=12
            elif (opt==3):
                x1 = vars[countrow]
                x2 = vars[countrow+1]
                x3 = vars[countrow+2]
                x4 = vars[countrow+3]
                if (x2>x3):
                    temp = x2
                    x2 = x3
                    x3 = temp
                my_csv.write("%f\t%f\t%f\t%f\t%f\n"%(D4demand,x1,x2,x3,x4))
                countrow+=4
            elif (opt==5):
                for j in range(12):
                    x1 = vars[countrow]
                    x2 = vars[countrow+1]
                    x3 = vars[countrow+2]
                    x4 = vars[countrow+3]
                    if (x2>x3):
                        temp = x2
                        x2 = x3
                        x3 = temp
                    my_csv.write("%f\t%f\t%f\t%f\t%f\n"%(D5demand[j],x1,x2,x3,x4))
                    countrow+=4
            my_csv.write("SEDIMENT STRATEGY\n")
            my_csv.write(str(sedopt)+"\n")
            my_csv.write("DrawdownDate  MinInflow(m3/s) MaxRate(m)  Duration(d) Frequency(y)    MAXWL(m)    MINDISCH(m3/s)  WIDTH(m)    SLOPE(-)    LENGTH(m)   GATELEVEL(m)    QDESIGN(m3/s)\n")
            if (sedopt==1):
                my_csv.write("%i\t%f\t%f\t%i\t%i\t%f\t%f\t%f\t%f\t%f\t%f\t%f\n"%(vars[countrow],vars[countrow+1],maxrate,vars[countrow+2],vars[countrow+3],maxwl,mindisch,width,slope,length,gatelevel,bottomcap))
                countrow+=4
            elif (sedopt==2):
                my_csv.write("%i\t%f\t%f\t%i\t%i\t%f\t%f\t%f\t%f\t%f\t%f\t%f\n"%(vars[countrow],vars[countrow+1],maxrate,vars[countrow+2],vars[countrow+3],maxwl,mindisch,width,slope,length,gatelevel,bottomcap))
                countrow+=4
        totalinstallcapcity+=0.9*9.81*height*discharge
    # 9.81 is the gravitational acceleration; 0.9 is turbine coefficient (change if needed but remember to change in routing model - reservoir.f)

    # Run routing model
    os.chdir('../../..')
    orche = subprocess.Popen(['python3', 'orchestratorTransboundary.py', str(port)])
    orche.wait()
    directory = f"VICRes/RoutingSetupCores/RoutingSetup3S{port}/Results"
    os.chdir(directory)
    
    

    os.chdir('..')
    
    
    
    return curr_sol

# -----------------------------------------------------------------------------------------------------------------------------------
# Open operation file
if __name__ == '__main__':
    start_time = time.time()
    number_of_days = 5479
    spinning_period = 0
    maximum_no_reservoirs = 9
    number_of_cores = 20
    reservoirs = [[0 for x in range(3)] for y in range(maximum_no_reservoirs)]  
    
    reservoirs[0][0] = 7
    reservoirs[1][0] = 11
    reservoirs[2][0] = 8
    reservoirs[3][0] = 109
    reservoirs[4][0] = 2
    reservoirs[5][0] = 3
    reservoirs[6][0] = 6
    reservoirs[7][0] = 22
    reservoirs[8][0] = 13

    
    
    # Setup intial conditions
    constraint = []
    num_var = 0
    os.chdir('../../ReservoirsCompromizeFlushing')
    for i in range(maximum_no_reservoirs):
        text_file = open('res'+str(reservoirs[i][0])+'.txt','r')
        lines = text_file.read().split('\n')
        hmax = float(lines[1].split('\t')[0])
        hmin = float(lines[1].split('\t')[1])
        opt = int(lines[8].split('\t')[0])
        vcap = float(lines[1].split('\t')[2])							#vcapacity
        vd = float(lines[1].split('\t')[3])								#vdead
        text_file.close()
        if (opt==1):													#simplified rule curve (OP1)
           constraint.append(Real(hmin,hmax))							#h1
           constraint.append(Real(hmin,hmax))							#h2
           constraint.append(Real(1,365))								#t1
           constraint.append(Real(1,365))								#t2
           num_var+=4
           reservoirs[i][1] = 1
        elif (opt==2):													#rule curve (OP2)
            for j in range(12):
                constraint.append(Real(hmin,hmax))						#hi (i = 1 - 12)
            num_var+=12
            reservoirs[i][1] = 2
        elif (opt==3):													#operating rule (OP3)
            constraint.append(Real(0.0001,(math.pi/2-0.0001)))			#x1 (0-pi/2), but avoid 0 and pi (90 degree)
            constraint.append(Real(vd,vcap))								#x2 (range from vdead to vcapacity)
            constraint.append(Real(vd,vcap))								#x3 (range from vdead to vcapacity), check condition later
            constraint.append(Real(0.0001,(math.pi/2-0.0001)))			#x4 (0-pi/2), but avoid 0 and pi (90 degree)
            num_var+=4
            reservoirs[i][1] = 3
        elif (opt==5):													#operating rule (OP5 or OP3 12 demand values)
            for j in range (12):
               constraint.append(Real(0.0001,(math.pi/2-0.0001)))			#x1 (0-pi/2), but avoid 0 and pi (90 degree)
               constraint.append(Real(vd,vcap))								#x2 (range from vdead to vcapacity)
               constraint.append(Real(vd,vcap))								#x3 (range from vdead to vcapacity), check condition later
               constraint.append(Real(0.0001,(math.pi/2-0.0001)))			#x4 (0-pi/2), but avoid 0 and pi (90 degree)
            num_var+=48
            reservoirs[i][1] = 5
        sedopt = int(lines[11].split('\t')[0])
        if (sedopt==1):
           constraint.append(Integer(1,365))                           #Drawdown Date
           constraint.append(Real(1,5000))                         #Minimum Inflow to activate drawdown
           constraint.append(Integer(1,30))                            #Duration in days
           constraint.append(Integer(1,16))                             #Frequency in years
           num_var+=4
           reservoirs[i][2] = 1
        if (sedopt==2):
           constraint.append(Integer(1,365))                           #Drawdown Date
           constraint.append(Real(5,5000))                         #Minimum Inflow to activate drawdown
           constraint.append(Integer(30,150))                            #Duration in days
           constraint.append(Integer(1,16))                             #Frequency in years
           num_var+=4
           reservoirs[i][2] = 2
        if (sedopt==0):
           reservoirs[i][2] = 0

    # Reading Parametrization of optimal solutions
    # Reading optimization results for sluicing
    os.chdir('../OptimalSolutions')
    
    filename1 = 'optimization_variables_flush_final1.txt'
    
    data1 = np.loadtxt(filename1)
    
    varnew = data1

    varnew_unique = np.unique(varnew, axis=0)

    # Cap values for each indicator (the ones used to normalize the values of each objective between 0 and 1 during the optimization)
    maxtotalpro = 10627501.095537942 #hp production
    maxfirm = 3.207057309002500e+04 #firm hp
    maxsed = 30

    os.chdir('../RoutingSetup3S_Opt/Results')
    # Call optimization function
    
    
    start = datetime.datetime.now()
    results = parallel_execution(varnew_unique, number_of_cores)
    
    end = datetime.datetime.now()
    
    # Finish and save results to files
    print("Start",start)
    print("End",end)
    print("Finish running simulations! See opt_objectives.txt and opt_variables.txt for results.")
    

    # END OF FILE
    # ------------------------------------------------------------------------------------------------------------------------------------------------ 